(in-package :trans-logic-test)

(defmacro is? (&rest args)
  `(is ,@args :test #'equal?)
  )
(defmacro symbol-hack (s &optional cs)
  `(string-to-symbol (symbol-to-string ,s) ,cs)
  )
(defun run-all-tests ()
  (tests
  ;;; TEST STRING FUNCS
   ;;; We do this to-string-to-symbol test because using a plain symbol causes a
   ;;; package-related inconsistency, thanks to how the reader works.
   (is (string-to-symbol "my-symbol") (symbol-hack 'my-symbol))
   (is (integer-to-string 1337) "1337")
   (is (symbol-to-string 'my-symbol) "my-symbol")
   (is (string-to-keyword "my-symbol") :my-symbol)
   (is (keyword-to-string :my-symbol) "my-symbol")
   (is (str-cat-ls '("a" "b" "c")) "abc")
   (is (str-cat "a" "b" "c") "abc")
   (is (are-strs-suffix '("1" "2" "3") "c3") t)
   (is (are-strs-prefix '("a" "b" "c") "b2") t)
   (is (is-str-suffix "b" "ab") t)
   (is (is-str-prefix "a" "ab") t)
   (is (str-has "abc" "123abcdefg!@#") '(3 6))
   (is (str-split "abc" "123abcdefg!@#") '("123" "defg!@#"))
   (is (str-split "abc" "123abcdefgabc!@#") '("123" "defg" "!@#"))
   (is (str-matches "abc" "123abcdefg!@#") t)
   (is (str-replace "abc" "XYZ" "123abcdefg!@#") "123XYZdefg!@#")
  ;;; TEST DATA ALGEBRA
   (is (empty-set? (mk-empty-set)) t)
   (is? (@set-or (@s 1 2 3) (@s 4 5 6)) (@s 1 2 3 4 5 6))
   (is? (@set-or (@s 1 2 3) 'empty) (@s 1 2 3))
   (is? (@set-and (@s 1 2 3) (@s 3 4 5 6)) (@s 3))
   (is? (@set-and (@s 1 2 3) (@s 4 5 6)) 'empty)
   (is? (@set-xor (@s 1 2 3 4 5) (@s 4 5 6 7 8)) (@s 1 2 3 6 7 8))
   (is? (@set-diff (@s 1 2 3 4 5) (@s 4 5 6 7 8)) (@s 1 2 3))
   (is? (has-elem? (@s 1 2 3) 2) t)
   (is? (has-elem? (@s 1 2 3) 2) (is-elem? 2 (@s 1 2 3)))
   (is? (@set<= (@s 1 2 3) (@s 1 2 3 4 5)) (@s 1 2 3))
   (is? (@set<= (@s 1 2 3) (@s 1 2 3)) (@s 1 2 3))
   (is? (@set= (@s 1 2 3) (@s 1 2 3)) (@s 1 2 3))
   (is? (@set= (@s 1 2 3) (@s 1 2 3 4)) 'empty)
   (is? (@set< (@s 1 2 3) (@s 1 2 3 4 5)) (@s 1 2 3))
   (is? (@set< (@s 1 2 3) (@s 1 2 3)) 'empty)
   (is? (@set>= (@s 1 2 3 4 5) (@s 1 2 3)) (@s 1 2 3 4 5))
   (is? (@set>= (@s 1 2 3) (@s 1 2 3)) (@s 1 2 3))
   (is? (@set> (@s 1 2 3 4 5) (@s 1 2 3)) (@s 1 2 3 4 5))
   (is? (@set> (@s 1 2 3) (@s 1 2 3)) 'empty)
   (is? (@size (@s 1 2 3 4 5)) 5)
   ;;;(is? (@powerset (@s 1 2)) (@s (@s 1 2) (@s 1) (@s 2) (@s)))
   (is? (@transpose (@c 1 2)) (@c 2 1))
   (is? (@compose (@c 1 2) (@c 2 3)) (@c 1 3))
   (is? (@compose (@c 1 2) (@c 3 4)) (@s))
   (is? (yin (@c 1 2)) 1)
   (is? (yang (@c 1 2)) 2)
   (is? (yin (@r (@c 1 2) (@c 3 4))) (@s 1 3))
   (is? (yang (@r (@c 1 2) (@c 3 4))) (@s 2 4))
  ;;; XXX Are the yin-yang ops over the clan correct?
   (is? (yin (@clan (@r (@c 1 2) (@c 3 4))
                   (@r (@c 5 6) (@c 7 8))))
       (@s 1 3 5 7))
   (is? (yang (@clan (@r (@c 1 2) (@c 3 4))
                    (@r (@c 5 6) (@c 7 8))))
       (@s 2 4 6 8))
   (is? (@inc-set 3) (@r (@c 0 1) (@c 1 2) (@c 2 3)))
   (is? (@dec-set 3) (@r (@c 0 -1) (@c 1 0) (@c 2 1)))
   (is (number? 1) t)
   (is (number? "1") nil)
   (is (symbol? 1) nil)
   (is (symbol? "1") t)
   (is (symbol? '|1|) t)
   (is (symb< "aardvark" "zulu") t)
   (is (symb< 'aardvark 'zulu) t)
   (is (symb< 'aardvark 'aardvark) nil)
   (is (symb< 'aardvark 'zulu) (symb> 'zulu 'aardvark))
   (is "nick" "nick")
   (is (symb= 'tautology "tautology") t)
   (is (symb= 'tautology 'tautology) t)
   (is (symb= "tautology" "tautology") t)
   (is (symb-cat 'foo 'bar) (symbol-hack 'foobar))
   (is (symb-cat "foo" "bar") "foobar")
   (is (symb-match "foobar" "^foo") t)
   (is (symb-match 'foobar "^foo") t)
   ;;; Reader hack
   (is (symb-reverse 'foobar) (symbol-hack 'raboof))
   (is (symb-reverse "foobar") "raboof")
   (is (symb-reverse (symb-reverse "foobar")) "foobar")
   ;;; Reader hack
   (is (symb-reverse (symb-reverse 'foobar)) (symbol-hack 'foobar))
   (is (symb-length "foobar") 6)
   (is (symb-length 'foobar) 6)
   (is (symb-upcase "foobar") "FOOBAR")
   (is (symb-upcase 'foobar) (symbol-hack 'FOOBAR))
   (is (symb-downcase 'foobar) (symbol-hack '|foobar| t))
   (is? (@diag (@s 1 2 3)) (@r (@c 1 1) (@c 2 2) (@c 3 3)))
   (is (yin-functional? (@r (@c 1 2) (@c 2 3))) t)
   (is (yin-functional? (@r (@c 1 2) (@c 2 2))) nil)
   (is (yang-functional? (@r (@c 2 1) (@c 3 2))) t)
   (is (yang-functional? (@r (@c 2 1) (@c 2 2))) nil)
   ;;; TODO test the higher-level data algebra.
   )
  )
